Voici ce que nous pouvons en déduire :

L'erreur 401 sur PUT /api/settings persiste : Le problème fondamental d'authentification lors de la tentative de sauvegarde est toujours présent. Le backend renvoie explicitement {"message":"Unauthorized: Please log in to access this resource"}.
Information cruciale : GET /api/auth/status réussit (Status 200) ! Juste avant l'échec du PUT, il y a un appel réussi à /api/auth/status. Cela signifie que, pour cette requête GET, le backend considère l'utilisateur comme authentifié et la session est probablement valide à ce moment-là.
Pourquoi cette différence entre GET (qui réussit) et PUT (qui échoue juste après) ?

Ce comportement où les requêtes GET fonctionnent mais les requêtes qui modifient l'état (PUT, POST, DELETE) échouent avec une erreur 401/403 pointe très fortement vers une cause probable :

Protection CSRF (Cross-Site Request Forgery) :

Comment ça marche : Les protections CSRF (comme le middleware csurf dans Express) exigent que les requêtes qui modifient l'état (POST, PUT, DELETE) incluent un jeton secret unique (le token CSRF) qui prouve que la requête provient bien de votre propre application et non d'un site externe malveillant. Les requêtes GET sont généralement exemptées de cette vérification car elles ne modifient pas l'état.
Pourquoi ça correspond : Si vous avez activé une protection CSRF sur votre backend en production, mais que votre frontend n'envoie pas le token CSRF correct avec la requête PUT /api/settings, le middleware CSRF rejettera la requête, souvent avec une erreur 401 ou 403. La requête GET /api/auth/status fonctionnerait car elle n'est pas soumise à cette vérification.
Action :
Vérifiez si vous utilisez un middleware CSRF (comme csurf) dans votre application Express en production.
Si oui, assurez-vous que :
Le backend génère un token CSRF et le rend accessible au frontend (souvent via un cookie ou injecté dans le HTML initial).
Votre code frontend récupère ce token et l'inclut dans les requêtes PUT/POST/DELETE (généralement dans un en-tête HTTP personnalisé comme X-CSRF-Token ou XSRF-TOKEN, ou dans le corps de la requête).
Inspectez la requête PUT échouée dans l'onglet "Network" pour voir si un en-tête ou un champ de corps de requête lié au CSRF est présent et correct.
Autres possibilités (moins probables mais à garder en tête si CSRF n'est pas en cause) :

Cookie non envoyé spécifiquement avec PUT : Même si peu probable si le GET juste avant fonctionne, revérifiez (Network tab > Request > Cookies) que le cookie de session est bien envoyé avec la requête PUT. L'attribut SameSite=Lax (comportement par défaut dans certains navigateurs) peut parfois restreindre l'envoi de cookies sur les requêtes cross-site POST/PUT mais pas GET, bien que cela soit moins courant si l'API et le frontend sont sur le même domaine principal.
Middleware d'authentification différent ou bogué pour PUT : Est-il possible que le middleware qui vérifie l'authentification (req.isAuthenticated(), req.session.user, etc.) s'exécute différemment ou ait une logique spécifique (et peut-être erronée) pour les routes PUT par rapport aux routes GET ? Vérifiez l'ordre et l'application des middlewares sur vos routes. Utilisez vos logs backend pour comparer l'exécution du middleware d'authentification pour le GET et le PUT.
Priorité immédiate : Enquêtez sur la protection CSRF. C'est le suspect numéro un étant donné le schéma GET OK / PUT échoué.